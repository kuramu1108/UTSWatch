<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"> 
		<meta name="viewport" content="width=device-width, height=device-height, user-scalable=no, initial-scale=1.0, maximum-scale=1.0"> 
		<title>UTS Watch MiniFab ver. V</title>
		
		<!-- Navigation CSS -->		
		<link rel="stylesheet" type="text/css" href="css/normalize.css" />
		<link rel="stylesheet" type="text/css" href="css/component.css" />
	    <link href="css/documentation.css" rel="stylesheet" />

		
		<!-- Geometry Script -->
		<script type="text/javascript" src="js/three.js"></script>
<!-- 		<script type="text/javascript" src="js/Geometry/three_mod.js"></script> -->
		<script type="text/javascript" src="js/Geometry/jquery-1.9.0.js"></script>
   		<script type="text/javascript" src="js/Geometry/stats.js"></script>
   		<script type="text/javascript" src="js/Geometry/dat.gui.js"></script>
   		<script type="text/javascript" src="js/OrbitControls.js"></script>
   		<script type="text/javascript" src="js/pointer.js"></script>
   		<script type="text/javascript" src="js/STLExporter.js"></script>
   		<script type="text/javascript" src="js/FileSaver.js"></script>
   		<script type="text/javascript" src="http://paulkaplan.me/Experiments/PixelPrinter/javascripts/mesh.js"></script>
   		<script type="text/javascript" src="http://paulkaplan.me/Experiments/lib/js/detector.js"></script>
   		
   		
   		
   		

   		<style>
	   		#WebGLcanvas {
			    overflow: hidden;
			    -ms-touch-action: none;
			}
			#WebGLcanvas {
			    position: absolute;
			    top:0;
			    bottom: 0;
			    left: 0;
			    right: 0;
			    margin:auto;
			}
		</style>	
	</head>
	
	<body>
			<!-------------- 3D Geometry Start Here ------------------->
						
					<!-- Div which will hold the Output -->
					<canvas id="WebGLcanvas"></canvas>
<!-- 					<div id="WebGL-output"></div>  -->
						<!-- Javascript code that runs our Three.js examples -->
						<script type="text/javascript">
						// variable for setting up the scene three.js and WebGL
						var scene, camera, webGLRenderer, step;
						var exportFile;
						// variable for shape holder
						var initialBezel, initialLug, initialFace, initialCrown, initialStrap;
						// variable for mesh holder
						var bezelMesh, lugMesh, faceMesh, crownMesh, strapMesh, strapMesh2;
						// variable for control holder
						var bezelControls, lugControls, faceControls, crownControls, strapControls;
						// variable for extrude option holder
						var bezelOptions, lugOptions, faceOptions, crownOptions, strapOptions;
						
						// variable for selecting object
						var raycaster = new THREE.Raycaster()						
						var mouse = new THREE.Vector2();
						var meshCollection = [];
						
						var strapWidth = 15;
						var bezel_radius = 35;					  
						
						// helping function
						function map(current, min,max,v)
						{
							if (v >= 1)
							{
								var temp = current + v * 0.2;
								if (temp >= max)
									temp = max;
							}
							else
							{
								var temp = current - 1 * v;
								if (temp <= min)
									temp = min;
							}
							return temp;
						}
						
						//touch event enable
						var thisOne = document.getElementById( "WebGLcanvas" );
						thisOne.addEventListener('gesturescale', function(e)
						{
							strapWidth = map(strapWidth,15,18,e.scale);
							updateStrapWidth();
						});
						
						thisOne.addEventListener("gesturedoubletap", function() {
							strapWidth = 18;
							updateStrapWidth();
						});
						
						function onWindowResize() {
			
			                camera.aspect = window.innerWidth / window.innerHeight;
			
			                camera.updateProjectionMatrix();
			
			                webGLRenderer.setSize( window.innerWidth, window.innerHeight );
			
			            }
						
						function onDocumentTouchStart( event ) {
				
							event.preventDefault();
							
							event.clientX = event.touches[0].clientX;
							event.clientY = event.touches[0].clientY;
							onDocumentMouseDown( event );
			
						}	
						var planes = [];
						function onDocumentMouseDown( event ) {
			
							event.preventDefault();
			
							mouse.x = ( event.clientX / $("#WebGLcanvas").width() ) * 2 - 1;
							mouse.y = - ( event.clientY / $("#WebGLcanvas").height() ) * 2 + 1;
							var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
							//projector.unproject( vector, camera );
							vector.unproject(camera);
							//raycaster.setFromCamera( mouse, camera );
							raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );
							var intersects = raycaster.intersectObjects( meshCollection, true);
							console.log(intersects.toString());
							if ( intersects.length > 0 ) {
			
								intersects[ 0 ].object.material.color.setHex( Math.random() * 0xffffff );
			
							}
						}
						
						
						//start rendering
						init();
						
						
						//update function
						function updateStrapWidth(){
							initialLug = drawLug();
							lugControls.asGeom();
							initialStrap = drawStrap();
							strapControls.asGeom();
						}
									
						function render() {	
						    //shape.rotation.y = step += 0.02;
							
							// render using requestAnimationFrame
							requestAnimationFrame(render);
							webGLRenderer.render(scene, camera);
					    }
					    
					    function drawLug() {
							var lugs = [];
				            // create a basic shape of lugs
				            var trlug = new THREE.Shape();
							//var strapWidth = 15;
							var form = 2;
							var ox = strapWidth;
							var oy = 46 - form * (strapWidth - 14);
							var limit = 25;
							trlug.moveTo(ox, oy);
							trlug.lineTo(limit, 46 - form * (limit - 14));
							trlug.lineTo(ox, (46 - form *(limit-14)));
							trlug.lineTo(ox, oy);
							
							var bllug = new THREE.Shape();
							bllug.moveTo(-ox, -oy);
							bllug.lineTo(-limit, -46 + form * (limit - 14));
							bllug.lineTo(-ox, -46 + form * (limit - 14));
							bllug.lineTo(-ox, -oy);
							
							var brlug = new THREE.Shape();
							brlug.moveTo(ox, -oy);
							brlug.lineTo(limit, -46 + form * (limit - 14));
							brlug.lineTo(ox, -46 + form * (limit - 14));
							brlug.lineTo(ox, -oy);
		
							var tllug = new THREE.Shape();
							tllug.moveTo(-ox, oy);
							tllug.lineTo(-limit, 46 - form * (limit - 14));
							tllug.lineTo(-ox, 46 - form * (limit - 14));
							tllug.lineTo(-ox, oy);
						// return the shape
							lugs.push(trlug);
							lugs.push(bllug);
							lugs.push(brlug);
							lugs.push(tllug);
				            return lugs;
				        }
			
						function drawBezel(r) {
			
				            // create a basic shape
				            var circle = new THREE.Shape();
							radius = r;
							
							for (var i = 0; i < 360; i++) {
								var pct = (i + 1) / 360;
								var theta = pct * Math.PI * 2.0;
								var x = radius * Math.cos(theta);
								var y = radius * Math.sin(theta);
								if (i == 0) 
								{
									circle.moveTo(x, y);
								} else {
									circle.lineTo(x, y);
								}
							}
							
							var hole = new THREE.Path();
							var iRadius = 26;
							for (var i = 0; i < 360; i++) {
								var pct = (i + 1) / 360;
								var theta = pct * Math.PI * 2.0;
								var x = iRadius * Math.cos(theta);
								var y = iRadius * Math.sin(theta);
								if (i == 0) 
								{
									hole.moveTo(x, y);
								} else {
									hole.lineTo(x, y);
								}
							}
							circle.holes.push(hole);
				            // return the shape
				            return circle;
				        }
				        
				        function drawWatchFace(r){
				        // create a basic shape
				            var circle = new THREE.Shape();
							radius = r;
							
							for (var i = 0; i < 360; i++) {
								var pct = (i + 1) / 360;
								var theta = pct * Math.PI * 2.0;
								var x = radius * Math.cos(theta);
								var y = radius * Math.sin(theta);
								if (i == 0) 
								{
									circle.moveTo(x, y);
								} else {
									circle.lineTo(x, y);
								}
							}
							
						    return circle;
				        }
						
						function drawCrown(){
							// create a basic shape
				            var circle = new THREE.Shape();
							radius = 5;
							
							for (var i = 0; i < 360; i++) {
								var pct = (i + 1) / 360;
								var theta = pct * Math.PI * 2.0;
								var x = radius * Math.cos(theta);
								var y = radius * Math.sin(theta);
								if (i == 0) 
								{
									circle.moveTo(x, y);
								} else {
									circle.lineTo(x, y);
								}
							}
							
							return circle;
				        }
				        
				        function drawStrap(){
							// create a basic shape
				            var rect = new THREE.Shape();
							rect.moveTo(strapWidth, 1);
							rect.lineTo(strapWidth, -1);
							rect.lineTo(-strapWidth, -1);
							rect.lineTo(-strapWidth, 1);
							rect.lineTo(strapWidth, 1);
							return rect;
				        }

				        
				        
				        function createMesh(geom) {
						    //geom.applyMatrix(new THREE.Matrix4().makeTranslation(-20, 0, 0));
						
						     // assign two materials
						     var meshMaterial = new THREE.MeshPhongMaterial( { color: 0x96b0be, specular:0x847c7c, shininess: 30, combine: THREE.MultiplyOperation} );
						
						     //  meshMaterial.side = THREE.DoubleSide;
						     var wireFrameMat = new THREE.MeshBasicMaterial();
						     wireFrameMat.wireframe = true;
						
						     // create a multimaterial
						     var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial]);
						     //var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [wireFrameMat]);
						
						     return mesh;
						}
						
						function shapeCreation(){
							initialBezel = drawBezel(bezel_radius);
						    initialLug = drawLug();
						    initialFace = drawWatchFace(bezel_radius);
						    initialCrown = drawCrown();
						    initialStrap = drawStrap();
				
						}
			


						    // once everything is loaded, we run our Three.js stuff.
						function init() {
							
							var container = document.getElementById( "WebGLcanvas" );					
							// create a scene, that will hold all our elements such as objects, cameras and lights.
						    scene = new THREE.Scene();
				
							// create a camera, which defines where we're looking at.
						    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
							scene.add(camera);
							// create a render and set the size
						    webGLRenderer = new THREE.WebGLRenderer({canvas: container});
							webGLRenderer.setClearColor(new THREE.Color(0x000000, 1.0));
						    webGLRenderer.setSize(window.innerWidth, window.innerHeight);
						    webGLRenderer.shadowMapEnabled = true;
						
							shapeCreation();
							var controler = new THREE.OrbitControls(camera, webGLRenderer.domElement);
							controler.noZoom = true;
					        // position and point the camera to the center of the scene
					        camera.position.x = 0;
					        camera.position.y = 0;
					        camera.position.z = 200;
					        camera.lookAt(new THREE.Vector3(0, 0, 0));
							
							//scene.add( new THREE.AmbientLight( 0xffffff ) );
	
							var light1 = new THREE.PointLight( 0xffffff, 0.3 );
							light1.position.set(0, 0, 150);
							scene.add( light1 );
							
							var light2 = new THREE.PointLight( 0xffffff, 0.3 );
							light2.position.set(-50, 50, 50);
							scene.add( light2 );
							
							var light3 = new THREE.PointLight( 0xffffff, 0.3 );
							light3.position.set(50, 50, 50);
							scene.add( light3 );
							
							var light4 = new THREE.PointLight( 0xffffff, 0.3 );
							light4.position.set(50, 50, -50);
							scene.add( light4 );
							
							var light5 = new THREE.PointLight( 0xffffff, 0.3 );
							light5.position.set(-50, 50, -50);
							scene.add( light5 );
							
							var light6 = new THREE.PointLight( 0xffffff, 0.3 );
							light6.position.set(50, 0, 0);
							scene.add( light6 );
					        // add the output of the renderer to the html element
					        //container.appendChild(webGLRenderer.domElement);
					        
					        var plane = new THREE.Mesh(
								new THREE.PlaneBufferGeometry( 5000, 20, 8, 8 ),
								new THREE.MeshBasicMaterial( { color: 0x000000, opacity: 0.25, transparent: true } )
							);
							/*
plane.visible = true;
							scene.add( plane );
							var plane2 = new THREE.Mesh(
								new THREE.PlaneBufferGeometry( 20, 2000, 8, 8 ),
								new THREE.MeshBasicMaterial( { color: 0x000000, opacity: 0.25, transparent: true } )
							);
							plane2.visible = true;
							scene.add( plane2 );
							planes.push(plane);
							planes.push(plane2);
*/
														
							webGLRenderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
							webGLRenderer.domElement.addEventListener( 'touchstart', onDocumentTouchStart, false );
							
							window.addEventListener( 'resize', onWindowResize, false );
					        // call the render function
					        step = 0;
						
					        // setup the control for Bezel
					        bezelControls = new function () {
						        this.amount = 2;
						        this.bevelThickness = 2;
								this.bevelSize = 0.5;
						        this.bevelSegments = 3;
								this.bevelEnabled = true;
						        this.curveSegments = 12;
						        this.steps = 1;
								this.curveA = 10;
								this.curveB = 15;
						        this.asGeom = function () {
						            scene.remove(bezelMesh);
									// create a new one

					                bezelOptions = {
						                    amount: bezelControls.amount,
						                    bevelThickness: bezelControls.bevelThickness,
						                    bevelSize: bezelControls.bevelSize,
						                    bevelSegments: bezelControls.bevelSegments,
						                    bevelEnabled: bezelControls.bevelEnabled,
						                    curveSegments: bezelControls.curveSegments,
						                    steps: bezelControls.steps,
											curveA: bezelControls.curveA,
											curveB: bezelControls.curveB
						            };
						
						            bezelMesh = createMesh(new THREE.ExtrudeGeometry(initialBezel, bezelOptions));
						            // add it to the scene.									
									scene.add(bezelMesh);
									meshCollection.push(bezelMesh);
								};
						
						    }
						    
							// control for lug
						    lugControls = new function () {
						        this.amount = 2;
						        this.bevelThickness = 1;
								this.bevelSize = 0.5;
						        this.bevelSegments = 3;
								this.bevelEnabled = true;
						        this.curveSegments = 12;
						        this.steps = 1;
								this.curveA = 10;
								this.curveB = 15;
						        this.asGeom = function () {
						            // remove the old plane
						            scene.remove(lugMesh);
									// create a new one

					                lugOptions = {
						                    amount: lugControls.amount,
						                    bevelThickness: lugControls.bevelThickness,
						                    bevelSize: lugControls.bevelSize,
						                    bevelSegments: lugControls.bevelSegments,
						                    bevelEnabled: lugControls.bevelEnabled,
						                    curveSegments: lugControls.curveSegments,
						                    steps: lugControls.steps,
											curveA: lugControls.curveA,
											curveB: lugControls.curveB
						            };
						
						            lugMesh = createMesh(new THREE.ExtrudeGeometry(initialLug, lugOptions));
						            // add it to the scene.
									scene.add(lugMesh);
									meshCollection.push(lugMesh);
						        };
						
						    }
							// control for watch face
						    faceControls = new function () {
						        this.amount = .5;
						        this.bevelThickness = 0;
								this.bevelSize = 0;
						        this.bevelSegments = 0;
								this.bevelEnabled = false;
						        this.asGeom = function () {
						            // remove the old plane
						            //scene.remove(shape);
						            scene.remove(faceMesh);
									// create a new one

					                faceOptions = {
						                    amount: faceControls.amount,
						                    bevelThickness: faceControls.bevelThickness,
						                    bevelSize: faceControls.bevelSize,
						                    bevelSegments: faceControls.bevelSegments,
						                    bevelEnabled: faceControls.bevelEnabled,
						                    
						            };
						            faceMesh = createMesh(new THREE.ExtrudeGeometry(initialFace, faceOptions));
						            // add it to the scene.
									//scene.add(shape);
									scene.add(faceMesh);
									meshCollection.push(faceMesh);
						        };
						
						    }
						    // control for crown
						    crownControls = new function () {
						        this.amount = 2;
						        this.bevelThickness = 1;
								this.bevelSize = 0.5;
						        this.bevelSegments = 3;
								this.bevelEnabled = true;
						        this.curveSegments = 12;
						        this.steps = 1;
								this.curveA = 10;
								this.curveB = 15;
						        this.asGeom = function () {
						            // remove the old plane
						            //scene.remove(shape);
						            scene.remove(crownMesh);
									// create a new one

					                crownOptions = {
						                    amount: crownControls.amount,
						                    bevelThickness: crownControls.bevelThickness,
						                    bevelSize: crownControls.bevelSize,
						                    bevelSegments: crownControls.bevelSegments,
						                    bevelEnabled: crownControls.bevelEnabled,
						                    curveSegments: crownControls.curveSegments,
						                    steps: crownControls.steps,
											curveA: crownControls.curveA,
											curveB: crownControls.curveB
						            };
						
						            crownMesh = createMesh(new THREE.ExtrudeGeometry(initialCrown, crownOptions));
						            // add it to the scene.
									//scene.add(shape);
									scene.add(crownMesh);
									crownMesh.rotation.y = Math.PI/2;
									crownMesh.position.set(bezel_radius - this.amount/2, 0, 0);
									meshCollection.push(crownMesh);
						        };
						
						    }
						    //control for strap
						    strapControls = new function () {
								this.bevelEnabled = false;
						        this.steps = 200;
								var roundPath = [];
								for (var i = 0; i < 180; i++) {
									var pct = (i + 1) / 360;
									var theta = pct * Math.PI * 2.0;
									var y = 35 * Math.cos(theta);
									var z = 35 * Math.sin(theta);
									roundPath.push(new THREE.Vector3(0, y, z));
								}

								this.extrudePath = new THREE.SplineCurve3(roundPath);
						        this.asGeom = function () {
						            // remove the old plane
						            //scene.remove(shape);
						            scene.remove(strapMesh);
						            scene.remove(strapMesh2);
									// create a new one

					                strapOptions = {
						                    
						                    bevelEnabled: strapControls.bevelEnabled,
						                    steps: strapControls.steps,
											extrudePath: strapControls.extrudePath
						            };
						
						            strapMesh = createMesh(new THREE.ExtrudeGeometry(initialStrap, strapOptions));
						            strapMesh2 = createMesh(new THREE.ExtrudeGeometry(initialStrap, strapOptions));
						            // add it to the scene.
									//scene.add(shape);
									scene.add(strapMesh);
									scene.add(strapMesh2);
									strapMesh.rotation.x = Math.PI/2;
									strapMesh.position.set(0, -bezel_radius, -35);
									strapMesh2.rotation.x = -Math.PI/2;
									strapMesh2.position.set(0, bezel_radius, -35);
									meshCollection.push(strapMesh);
									meshCollection.push(strapMesh2);
						        };
						
						    }
						        
								// Chris : Here applied CSS to change location of dropdown menu
								// CSS at component.css line 332
						        var gui = new dat.GUI();
								gui.domElement.id = 'gui';
						        gui.add(bezelControls, 'amount', 0, 20).onChange(bezelControls.asGeom);
						        gui.add(bezelControls, 'bevelThickness', 0, 10).onChange(bezelControls.asGeom);
						        gui.add(bezelControls, 'bevelSize', 0, 10).onChange(bezelControls.asGeom);
						        gui.add(bezelControls, 'bevelSegments', 0, 30).step(1).onChange(bezelControls.asGeom);
						        gui.add(bezelControls, 'bevelEnabled').onChange(bezelControls.asGeom);
						        gui.add(bezelControls, 'curveSegments', 1, 30).step(1).onChange(bezelControls.asGeom);
						        gui.add(bezelControls, 'steps', 1, 5).step(1).onChange(bezelControls.asGeom);

						        bezelControls.asGeom();
						        lugControls.asGeom();
						        faceControls.asGeom();
						        crownControls.asGeom();
						        strapControls.asGeom();
						        //changes the values, removes the old plane, draws a new shape to the screen
						        //shape.rotation.y = 150;
						        render();

					    }
					    
					    
					    //EXPORT###
					   
					    function save() {
					     	exportFile = new THREE.ExtrudeGeometry(initialBezel, bezelOptions);
						 	var geometry_p2 = new THREE.ExtrudeGeometry(initialLug, lugOptions);
					    
						 	THREE.GeometryUtils.merge( exportFile, geometry_p2 );
							var stl = startExport();

							var blob = new Blob([stl], {type: 'text/plain'});
							saveAs(blob, 'pixel_printer.stl');
						}
							
						function startExport(){

							var stl = generateSTL( exportFile );
							return stl;
						}
					    //EXPORT###
					    
				
						</script>
				<!-- The Geometry End Here -->
						
		<!-- Navigation Menu -->
		<div class="container">
			<ul id="gn-menu" class="gn-menu-main">
				<li class="gn-trigger">
					<a class="gn-icon gn-icon-menu"><span>Menu</span></a>
					<nav class="gn-menu-wrapper">
						<div class="gn-scroller">
							<ul class="gn-menu">
								<li class="">
									<input placeholder="Search" type="search" class="gn-search">
									<a class="gn-icon gn-icon-search"><span>Search</span></a>
								</li>
								<li>
									<a class="gn-icon gn-icon-download">Edit</a>
									<ul class="gn-submenu">
										<li><a class="gn-icon gn-icon-illustrator">Account</a></li>
										<li><a class="gn-icon gn-icon-article">Sample Design</a></li>
									</ul>
								</li>
								<li><a class="gn-icon gn-icon-cog">Settings</a></li>
								<li><a class="gn-icon gn-icon-help">Help</a></li>
							</ul>
						</div><!-- /gn-scroller -->
					</nav>
				</li>
				<li><a href="../index.html">UTS Watch</a></li>
				<li><a class="" href="javascript:save();">Export</a></li>
			</ul>
		</div><!-- menu container end -->
		
		<!-- Script for Navigation Menu -->
		<script src="js/classie.js"></script>
		<script src="js/gnmenu.js"></script>
		<script>
			new gnMenu( document.getElementById( 'gn-menu' ) );
		</script>
	</body>
</html>